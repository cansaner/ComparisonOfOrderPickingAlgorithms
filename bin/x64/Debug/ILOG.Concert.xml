<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ILOG.Concert</name>
    </assembly>
    <members>
        <member name="T:ILOG.Concert.Exception">
            <summary>
            This is the base class for exceptions for the <tt>ILOG.Concert</tt> package.
            </summary>
            <remarks>  All exceptions (other than <c>RuntimeExceptions</c>) thrown by a
             method of an IBM ILOG Concert Technology object are derived from this class.</remarks>
        </member>
        <member name="M:ILOG.Concert.Exception.#ctor(System.String)">
            <summary>
            Creates an exception with its corresponding message.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:ILOG.Concert.Exception.#ctor">
            <summary>
            Creates an exception without a message.
            </summary>
        </member>
        <member name="T:ILOG.Concert.IAddable">
             <summary>
             This interface is used for modeling objects.
             </summary>
            <remarks>Objects of classes
             implementing this interface can be added to an instance of <c>IModel</c>.
             Constraint classes, such as <c>IRange</c>, and classes representing
             optimization objectives, such as <c>IObjective</c>, are examples.
             <p>
             All addable modeling objects can be assigned a name with the method
             <c>setName()</c>. The name can be queried with the method <c>
             getName()</c>. Assigning a name is not required. Modeling objects are
             created without an assigned name unless a name is specified in the
             construction.</p></remarks>
        </member>
        <member name="T:ILOG.Concert.ICopyable">
            <summary>
            This interface defines the API for elements of optimization models, such
            as variables, constraints, expressions, and objectives. 
            </summary>
            <remarks>Objects of classes implementing this interface can be copied when needed to an
            application using IBM ILOG Concert Technology for .NET. All objects used
            for describing an optimization model implement this interface.</remarks>
        </member>
        <member name="M:ILOG.Concert.ICopyable.MakeClone(ILOG.Concert.CloneManager)">
            <summary>
            This method must be implemented so that it copies the invoking object
            to the engine of the given copy manager using the copy manager.
            </summary>
        </member>
        <member name="M:ILOG.Concert.ICopyable.VisitChildren(ILOG.Concert.ICopyableVisitor)">
            <summary>
            This method is called when the object and all its sub-objects must be
            visited. To implement this method, you should first call the method
            <c>ICopyableVisitor.BeginVisit()</c> with yourself as parameter,
            then call <c>ICopyableVisitor.VisitChild()</c> for each
            sub-copyables, the call <c>ICopyableVisitor.EndVisit()</c> once
            again with yourself as parameter.
            </summary>
        </member>
        <member name="P:ILOG.Concert.IAddable.Name">
               <summary>
               Accesses/sets the name assigned to the invoking modeling object. If the
               invoking modeling object has not been assigned a name, <c>null</c> is
               returned.
               </summary>
        </member>
        <member name="T:ILOG.Concert.IAnd">
             <summary>
             This interface defines the API for classes that represent and-constraints.
             </summary>
            <remarks>  <p>
             An <c>IAnd</c> constraint is a multiple set of constraints. 
             Objects of type <c>IConstraint</c> can be added to and removed from 
             an instance of <c>IAnd</c>. 
             The constraints in an and-constraint can be queried by the 
             enumerator returned by the method <c>enumerator</c>.
             </p></remarks>
        </member>
        <member name="T:ILOG.Concert.IConstraint">
              <summary>
              This interface defines the API for constraints.
              </summary>
             <remarks>Instances of <c>IConstraint</c>
              are <c>IAddable</c> objects and can be added to an <c>IModel</c>.
              Not all modeling objects are instances of <c>IConstraint</c>, for example,
              <c>IObjective</c> is not a constraint.
              Examples of constraints are <c>IRange</c> and
              <c>IloLPMatrix</c>. <c>IloLPMatrix</c> is available to users of CPLEX.
            
              <seealso cref="T:ILOG.Concert.IAddable"/><seealso cref="T:ILOG.Concert.IModel"/>
              </remarks>
              
        </member>
        <member name="T:ILOG.Concert.IIntExpr">
              <summary>
              This is the basic public interface for integer expressions.
              </summary>
             <remarks>Integer
              expressions are represented using objects of type <c>IIntExpr</c>.
              They are guaranteed to contain only variables of type <c>integer</c>
              and perform integer arithmetic. Integer expressions are created
              using integer variables and values with the numerical operations
              provided in <c>IModeler</c>.
              <p>
              Integer expressions and general expressions can be mixed. This is
              achieved by defining the interface <c>IIntExpr</c> as an
              extension of <c>INumExpr</c>. However, when an integer
              expression is used as an instance of <c>INumExpr</c>, the compile-time
              information is lost. For some optimizers, this will incur a runtime
              overhead because the type information needs to be regained at
              run time. This is documented for the optimizers where it is relevant.</p>
            
              <seealso cref="M:ILOG.Concert.IModeler.Negative"/>
              <seealso cref="M:ILOG.Concert.IModeler.Diff(Int32, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Diff(IIntExpr, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Diff(IIntExpr, Int32)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Prod(Int32, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Prod(IIntExpr, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Prod(IIntExpr, Int32)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Sum(Int32, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Sum(IIntExpr, IIntExpr)"/>
              <seealso cref="M:ILOG.Concert.IModeler.Sum(IIntExpr, Int32)"/>
              <seealso cref="M:ILOG.Concert.IModeler.IntVar"/>
              </remarks>
              
        </member>
        <member name="T:ILOG.Concert.INumExpr">
             <summary>
             This is the public basic interface for all numerical expressions.
             </summary>
            <remarks>  Numerical expressions are represented by objects implementing this
             interface. They are constructed using the expression operator functions
             defined in the interface <c>IModel</c> or one of its extensions.
             <para>
             IBM ILOG Concert Technology distinguishes integer expressions that are built
             solely from integer variables and use only integer values. Integer
             expressions are represented by the interface <c>IIntExpr</c>, an
             extension of <c>INumExpr</c>. Integer expressions can be used
             wherever general expressions of type <c>INumExpr</c> are
             expected.</para>
             <para>
             Variables defined by the interface <c>INumVar</c> or
             <c>IIntVar</c> are also extensions of <c>INumExpr</c>. Therefore,
             variables can be used wherever general expressions are expected.</para>
             <seealso cref="M:ILOG.Concert.IModeler.Diff(Double, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Diff(INumExpr, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Diff(INumExpr, Double)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Prod(Double, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Prod(INumExpr, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Prod(INumExpr, Double)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Sum(Double, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Sum(INumExpr, INumExpr)"/>
             <seealso cref="M:ILOG.Concert.IModeler.Sum(INumExpr, Double)"/>
             <seealso cref="T:ILOG.Concert.IIntVar"/>
             <seealso cref="T:ILOG.Concert.ILinearIntExpr"/>
             <seealso cref="T:ILOG.Concert.IIntExpr"/>
             <seealso cref="T:ILOG.Concert.INumVar"/>
             <seealso cref="T:ILOG.Concert.ILinearNumExpr"/>
             </remarks>
             
        </member>
        <member name="M:ILOG.Concert.IAnd.Add(ILOG.Concert.IConstraint)">
             <summary>
             This method adds the constraint to the invoking and-constraint.
             </summary>
            <param name="ct">The constraint to be added to the invoking 
                           instance of <c>IAnd</c>.
             </param>
             <returns>The constraint that has been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IAnd.Add(ILOG.Concert.IConstraint[])">
             <summary>
             This method adds the array of constraints to the invoking
             and-constraint.
             </summary>
            <param name="objects">The array of constraints to be added to the
                            invoking instance of <c>IAnd</c>.
             </param>
             <returns>The array of constraints that have been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IAnd.Add(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
              <summary>
              This method adds constraints to the invoking 
              instance of <c>IAnd</c>.
              </summary>
             <remarks>  <p>
              All objects implementing the <c>IConstraint</c> interface
              <c>objects[start]...objects[start+num-1]</c> are added to
              the invoking <c>IAnd</c> object.
              </p>
              
            
            
             </remarks>
             <param name="objects">The array of constraints to be added
                             to the invoking instance of <c>IAnd</c>.
              </param>
              <param name="start">The first constraint to be added to the
                           invoking instance of <c>IAnd</c>.
              </param>
              <param name="num">The number of constraints to be added to
                         the invoking instance of <c>IAnd</c>.
              </param>
              <returns>The array of constraints that have been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IAnd.Remove(ILOG.Concert.IConstraint)">
              <summary>
              This method removes the constraints from the invoking
              and-constraint.
              </summary>
             <remarks>
              <p>If the constraint has been added multiple times, only one 
             	instance is removed from the and-constraint.
              </p>
            
              </remarks>
              <param name="ct">The constraint to be removed from the invoking
                                instance of <c>IAnd</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IAnd.Remove(ILOG.Concert.IConstraint[])">
             <summary>
             This method removes the array of constraints
             from the invoking and-constraint.
             </summary>
            <param name="objects">The array of constraints to be removed from the
                           invoking <c>IAnd</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IAnd.Remove(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
              <summary>
              This method removes constraints from the invoking instance of 
              <c>IAnd</c>.
              </summary>
             <remarks>  <p>
              The constraints or, more precisely, the objects implementing
              the <c>IConstraint</c> interface
              <c>objects[start]...objects[start+num-1]</c> are removed
              from the invoking instance of <c>IAnd</c>. If a constraint
              has been added multiple times, only one instance is removed
              from the and-constraint.
              </p>
              
            
             </remarks>
             <param name="objects">The array of constraints to be removed
                             from the invoking instance of <c>IAnd</c>.
              </param>
              <param name="start">The first constraints to be removed from the
                           invoking instance of <c>IAnd</c>.
              </param>
              <param name="num">The number of constraints to be removed from
                         the invoking instance of <c>IAnd</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IAnd.GetEnumerator">
             <summary>
             This method returns an enumerator that traverses the constraints in
             the and-constraint.
             </summary>
            <remarks>
             <p>Any manipulation of the and-constraint will render an
             enumerator accessed with this method invalid. An enumerator
             can be used only until the method <c>Add, Remove</c>, or
             <c>Delete</c> is called on the invoking instance of 
             <c>IAnd</c>. </p></remarks>
        </member>
        <member name="T:ILOG.Concert.ICopyableVisitor">
            <summary>
            A visitor of ICopyable. See <c>ICopyable.VisitChildren</c> for details.
            <seealso cref="M:ILOG.Concert.ICopyable.VisitChildren"/></summary>
        </member>
        <member name="T:ILOG.Concert.CloneManager">
            <summary>
            Manage copies of ICopyable objects.
            </summary>
        </member>
        <member name="T:ILOG.Concert.SimpleCloneManager">
            <exclude/>
        </member>
        <member name="T:ILOG.Concert.IIntCollectionVar">
             <summary>
             This interface defines the API for variable classes that can represent
             collections.
             </summary>
        </member>
        <member name="P:ILOG.Concert.INumVar.Type">
               <summary>
               Queries/sets the type of the invoking <c>INumVar</c> object.
               </summary>
        </member>
        <member name="P:ILOG.Concert.INumVar.LB">
               <summary>
               Queries/sets the lower bound of the invoking <c>INumVar</c> object.
               </summary>
        </member>
        <member name="P:ILOG.Concert.INumVar.UB">
               <summary>
               Queries/sets the upper bound of the invoking <c>INumVar</c> object.
               </summary>
        </member>
        <member name="P:ILOG.Concert.INumVar.Name">
               <summary>
               Queries/sets the name of the invoking variable.
               </summary>
        </member>
        <member name="P:ILOG.Concert.IIntVar.Min">
               <summary>
               Accesses/sets the initial minimum value for this integer variable.
               </summary>
        </member>
        <member name="P:ILOG.Concert.IIntVar.Max">
               <summary>
               Accesses/sets the initial maximum value for this integer variable.
               </summary>
        </member>
        <member name="T:ILOG.Concert.ILinearIntExpr">
              <summary>
              This is the interface for scalar product expressions for integer variables.
              </summary>
             <remarks>  <para>Objects of type <c>ILinearIntExpr</c> represent integer
              linear expressions of the form</para>
              <para>
                       <c>sum_{i=1..n} a_i * x_i + c</c>
              </para>
              <para>where <c>x_i</c> are variables of type <c>IIntVar</c> and
              <c>c</c> and <c>a_i</c> are integer values. Note that the
              variable types must be known at compile time for use with
              <c>ILinearIntExpr</c>. The java type of the variables must be
              <c>IIntVar</c> and cannot be <c>INumVar</c> with
              variable type <c>NumVarType.Int</c>.</para>
              <para>
              <c>ILinearIntExpr</c> objects are created with the methods:</para>
              <ul>
               <li><c>IModeler.LinearIntExpr()</c></li>
               <li><c>IModeler.ScalProd()</c></li>
              </ul>
              <para>
              Once created, integer linear expressions can be fully edited:</para>
              <ul>
              <li>new terms <c>a_i * x_i</c> can be added;</li>
              <li>coefficients of existing terms can be modified;</li>
              <li>existing terms can be removed;</li>
              <li>the constant can be reset.</li>
              </ul>
              <para>All the information stored in an <c>ILinearIntExpr</c> object can be
              queried. The constant term is accessed through the method <c>getConstant()</c>.
              The values and variables of the terms <c>a_i * x_i</c> are accessed using
              enumerator objects of type <c>ILinearIntExpr.Enumerator</c> that
              can be created using the method <c>GetLinearEnumerator()</c>.</para>
            
              <seealso cref="M:ILOG.Concert.IModeler.ScalProd(Int32[], IIntVar[])"/>
              <seealso cref="M:ILOG.Concert.IModeler.LinearIntExpr()"/>  
              
              </remarks>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerm(System.Int32,ILOG.Concert.IIntVar)">
             <summary>
             Adds the new term <c>coef * var</c> to a scalar product.
             </summary>
            <remarks>  <p>
             No checks are performed to verify
             that the invoking <c>ILinearIntExpr</c> object does not contain
             a term with the same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
             </p>
             
            </remarks>
            <param name="coef">The coefficient of the added term.
             </param>
             <param name="var">The variable of the added term.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerm(ILOG.Concert.IIntVar,System.Int32)">
             <summary>
             Adds the new term <c>coef * var</c> to a scalar product.
             </summary>
            <remarks>  <p>
             No checks are performed to verify that the invoking
             <c>ILinearIntExpr</c> object does not contain
             a term with the same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
            </p>
             
            </remarks>
            <param name="var">The variable of the added term.
             </param>
             <param name="coef">The coefficient of the added term.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerms(System.Int32[],ILOG.Concert.IIntVar[],System.Int32,System.Int32)">
              <summary>
              Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
              </summary>
             <remarks>  <p>
              No checks are performed to verify
              that the invoking <c>ILinearIntExpr</c> object does not contain
              a term with the same variable <c>var</c>. This method can create
              duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
              could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
              </p><p>
              Duplicates do not generate errors but require more memory and more 
              running time when iterating through the terms of an <c>ILinearIntExpr</c>.
              </p>
            
             </remarks>
             <param name="coef">The coefficients of the added terms.
              </param>
              <param name="var">The variables of the added terms.
              </param>
              <param name="start">The first element in <c>coef, var</c> to be added.
              </param>
              <param name="num">The number of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerms(ILOG.Concert.IIntVar[],System.Int32[],System.Int32,System.Int32)">
             <summary>
             Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
             </summary>
            <remarks>  <p>
             No checks are performed to verify
             that the invoking <c>ILinearIntExpr</c> object does not contain
             terms with the same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
             </p>
            </remarks>
            <param name="var">The variables of the added terms.
             </param>
             <param name="coef">The coefficients of the added terms.
             </param>
             <param name="start">The first element in <c>coef, var</c> to be added.
             </param>
             <param name="num">The number of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerms(System.Int32[],ILOG.Concert.IIntVar[])">
             <summary>
             Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
             </summary>
            <remarks>  <p>
             No checks are performed to verify
             that the invoking <c>ILinearIntExpr</c> object does not contain
             terms with the same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
             </p>
             
            </remarks>
            <param name="coef">The coefficients of added terms.
             </param>
             <param name="var">The variables of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.AddTerms(ILOG.Concert.IIntVar[],System.Int32[])">
             <summary>
             Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
             </summary>
            <remarks>  <p>
             No checks are performed to verify
             that the invoking <c>ILinearIntExpr</c> object does not contain
             terms with the same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
             </p>
             
            </remarks>
            <param name="var">The variables of added terms.
             </param>
             <param name="coef">The coefficients of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.Add(ILOG.Concert.ILinearIntExpr)">
             <summary>
             Adds all the terms found in the scalar product passed as argument to the
             invoking object.
             </summary>
            <remarks>  <p>
             No checks are performed to verify that the invoking
             <c>ILinearIntExpr</c> object does not contain terms with the same
             variable <c>var</c>. This method can create duplicate terms
             <c>... + a_i * x + ... + a_k * x + ...</c> that could be joined
             to a single term <c>... + (a_i + a_k) * x + ...</c>.
             </p><p>
             Duplicates do not generate errors but require more memory and more 
             running time when iterating through the terms of an <c>ILinearIntExpr</c>.
             </p>
             </remarks>
             <param name="sc">The scalar product expression, the terms of which are added
                               to the invoking object.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.Clear">
             <summary>
             Removes all terms from the invoking linear expression leaving a
             <c>0</c> expression behind.
             </summary>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.Remove(ILOG.Concert.IIntVar)">
             <summary>
             Removes a variable from the invoking <c>ILinearIntExpr</c> expression.
             </summary>
             <remarks>  All terms in the invoking linear expression with the specified variable are
              removed from the invoking <c>ILinearIntExpr</c> object.  If
              variable <c>var</c> occurs more than once in the invoking
              <c>ILinearIntExpr</c>, all occurrences are removed.  The
              <c>ILinearIntExpr.Enumerator</c> can be used to remove individual
              terms regardless of duplicates.
            
              </remarks>
              <param name="var">The variable to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.Remove(ILOG.Concert.IIntVar[],System.Int32,System.Int32)">
             <summary>
             Removes a set of variables from the invoking <c>ILinearIntExpr</c>
              expression.
              </summary>
             <remarks>All terms in the invoking linear expression having any
              variable in <c>var[start], ..., var[start+num-1]</c> are removed.
              If variable <c>var</c> occurs more than once in the invoking
              <c>ILinearIntExpr</c>, all occurrences are removed. The
              <c>ILinearIntExpr.Enumerator</c> can be used to remove individual
              terms regardless of duplicates.
            
              
            
             </remarks>
             <param name="var">The array containing the variables to be removed.
              </param>
              <param name="start">The index of the first variable in <c>var</c> to be removed.
              </param>
              <param name="num">The number of variables in <c>var</c> to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.Remove(ILOG.Concert.IIntVar[])">
              <summary>
              Removes a set of variables from the invoking <c>ILinearIntExpr</c>
              expression.
              </summary>
             <remarks>All terms in the invoking linear expression having any
              variable in <c>var[0], ..., var[num-1]</c>, where <c>num</c> is
              the length of array <c>var</c>, are removed from the invoking
              <c>ILinearIntExpr</c> object. If variable <c>var</c> occurs
              more than once in the invoking <c>ILinearIntExpr</c>, all
              occurrences are removed. The <c>ILinearIntExpr.Enumerator</c>
              can be used to remove individual terms regardless of duplicates.
            
              </remarks>
              <param name="var">The array of variables to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearIntExpr.GetLinearEnumerator">
             <summary>
             Returns an enumerator for the variables in the invoking
             <c>ILinearIntExpr</c> expression.
             </summary>
            <remarks> An enumerator allows
             the caller to enumerate all the terms of an <c>ILinearIntExpr</c>
             and to perform simple operations such as querying or modifying a term.
             An enumerator also allows the caller to remove elements from the underlying
             <c>ILinearIntExpr</c> during the iteration with well-defined
             semantics.</remarks>
        </member>
        <member name="P:ILOG.Concert.ILinearIntExpr.Constant">
               <summary>
               Queries the constant term from the invoking <c>ILinearIntExpr</c>.
               </summary>
        </member>
        <member name="T:ILOG.Concert.ILinearIntExprEnumerator">
             <summary>
             Enumerator for the linear terms of an <c>ILinearIntExpr</c>
             expression object.
             </summary>
        </member>
        <member name="P:ILOG.Concert.ILinearIntExprEnumerator.IntVar">
               <summary>
               Gets/sets the <c>IIntVar</c> accessed by the last call to the method <c>MoveNext()</c>.
               </summary>
        </member>
        <member name="P:ILOG.Concert.ILinearIntExprEnumerator.Value">
               <summary>
               Gets/sets the coefficient related to the <c>IIntVar</c> accessed by the last
               call to the method <c>MoveNext()</c>.
               </summary>
        </member>
        <member name="T:ILOG.Concert.ILinearNumExpr">
              <summary>
              This is the interface for scalar product expressions for
              numerical variables of any type.
              </summary>
             <remarks><para>Objects of type <c>ILinearNumExpr</c> represent linear expressions of the form</para>
              <para>
                       <c>sum_{i=1..n} a_i * x_i + c</c>
              </para>
              <para>where <c>x_i</c> are variables of type <c>INumVar</c> and
              <c>c</c> and <c>a_i</c> are double values.</para>
            
              <para><c>ILinearNumExpr</c> objects are created with methods:</para>
              <ul>
               <li><c>IModeler.LinearNumExpr()</c></li>
               <li><c>IModeler.ScalProd()</c></li>
              </ul>
            
              <para>Once created, integer linear expressions can be fully edited:</para>
              <ul>
              <li>new terms <c>a_i * x_i</c> can be added;</li>
              <li>coefficients of existing terms can be modified;</li>
              <li>existing terms can be removed;</li>
              <li>the constant can be reset.</li>
              </ul>
            
              <para>All the information stored in a <c>ILinearNumExpr</c> object can be
              queried as well. The constant term is accessed via method
              <c>getConstant()</c>. The values and variables of the terms
              <c>a_i * x_i</c> are accessed using enumerator objects of type
              <c>ILinearNumExpr.Enumerator</c> that can be created using method
              <c>GetLinearEnumerator()</c>.</para>
            
             <seealso cref="M:ILOG.Concert.IModeler.ScalProd(Double[], INumVar[])"/> 
             <see cref="M:ILOG.Concert.IModeler.LinearNumExpr()"/>
              </remarks>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerm(System.Double,ILOG.Concert.INumVar)">
             <summary>
             Adds the new term <c>coef * var</c> to a scalar product.
             </summary>
            <remarks> <para>The caller must ensure that the variable being added is not yet
             part of the invoking <c>ScalProd</c>.
             If this cannot be asserted, use the method <c>SetCoef</c> instead.</para>
             <para>
             No checks are performed to ensure that the invoking
             <c>ILinearNumExpr</c> object does not contain a term with the
             same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</para>
             <para>
             Duplicates do not generate errors but require more memory and more
             running time when iterating through the terms of an <c>ILinearNumExpr</c>.</para>
            </remarks>
            <param name="coef">The coefficient of the added term.
             </param>
             <param name="var">The variable of the added term.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerm(ILOG.Concert.INumVar,System.Double)">
             <summary>
             Adds the new term <c>coef * var</c> to a scalar product.
             </summary>
            <remarks><para>The caller must ensure that the variable being added is not yet part
             of the invoking <c>ScalProd</c>.
             If this cannot be asserted, use the method <c>setCoef</c> instead.</para>
             <para>
             No checks are performed to ensure that the invoking
             <c>ILinearNumExpr</c> object does not contain a term with the
             same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</para>
             <para>
             Duplicates do not generate errors but require more memory and more
             running time when iterating through the terms of an <c>ILinearNumExpr</c>.</para>
            </remarks>
            <param name="var">The variable of the added term.
             </param>
             <param name="coef">The coefficient of the added term.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerms(System.Double[],ILOG.Concert.INumVar[],System.Int32,System.Int32)">
             <summary>
             Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
             </summary>
            <remarks>  <para>The caller must ensure that the variables being added are not yet part of
             the invoking <c>ScalProd</c>.
             If this cannot be asserted, use the method <c>setCoef</c> instead.</para>
             <para>
             No checks are performed to ensure that the invoking
             <c>ILinearNumExpr</c> object does not contain a term with the
             same variable <c>var</c>. This method can create
             duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
             could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</para>
             <para>
             Duplicates do not generate errors but require more memory and more
             running time when iterating through the terms of an <c>ILinearNumExpr</c>.</para>
            </remarks>
            <param name="coef">The coefficients of the added terms.
             </param>
             <param name="var">The variables of the added terms.
             </param>
             <param name="start">The first element in <c>coef, var</c> to be added.
             </param>
             <param name="num">The number of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerms(ILOG.Concert.INumVar[],System.Double[],System.Int32,System.Int32)">
              <summary>
              Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
              </summary>
             <remarks>  The caller must ensure that the variables being added are not yet part of
              the invoking <c>IloScalProd</c>.
              If this cannot be asserted, use the method <c>setCoef</c> instead.
              <p>
              No checks are performed to ensure that the invoking
              <c>ILinearNumExpr</c> object does not contain a term with the
              same variable <c>var</c>. This method can create
              duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
              could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</p>
              <p>
              Duplicates do not generate errors but require more memory and more
              running time when iterating through the terms of an <c>ILinearNumExpr</c>.</p>
            
             </remarks>
             <param name="var">The variables of the added terms.
              </param>
              <param name="coef">The coefficients of the added terms.
              </param>
              <param name="start">The first element in <c>coef, var</c> to be added.
              </param>
              <param name="num">The number of added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerms(System.Double[],ILOG.Concert.INumVar[])">
              <summary>
              Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
              </summary>
             <remarks>  The caller must ensure that the variables being added are not yet part of
              the invoking <c>IloScalProd</c>.
              If this cannot be asserted, use the method <c>setCoef</c> instead.
              <p>
              No checks are performed to ensure that the invoking
              <c>ILinearNumExpr</c> object does not contain a term with the
              same variable <c>var</c>. This method can create
              duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
              could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</p>
              <p>
              Duplicates do not generate errors but require more memory and more
              running time when iterating through the terms of an <c>ILinearNumExpr</c>.</p>
            
              
             </remarks>
             <param name="coef">The coefficients of the added terms.
              </param>
              <param name="var">The variables of the added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.AddTerms(ILOG.Concert.INumVar[],System.Double[])">
             <summary>
             Adds the new terms <c>sum_i(coef[i] * var[i])</c> to a scalar product.
             </summary>
             <remarks>  The caller must ensure that the variables being added are not yet part of
              the invoking <c>IloScalProd</c>.
              If this cannot be asserted, use the method <c>setCoef</c> instead.
              <p>
              No checks are performed to ensure that the invoking
              <c>ILinearNumExpr</c> object does not contain a term with the
              same variable <c>var</c>. This method can create
              duplicate terms <c>... + a_i * x + ... + a_k * x + ...</c> that
              could be joined to a single term <c>... + (a_i + a_k) * x + ...</c>.</p>
              <p>
              Duplicates do not generate errors but require more memory and more
              running time when iterating through the terms of an <c>ILinearNumExpr</c>.</p>
            
              
             </remarks>
             <param name="var">The variables of the added terms.
              </param>
              <param name="coef">The coefficients of the added terms.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.Add(ILOG.Concert.ILinearNumExpr)">
             <summary>
             Adds all the terms found in the scalar product passed as argument to the
             invoking object.
             </summary>
            <remarks>The caller must ensure that the variables being added
             are not yet part of the invoking <c>IloScalProd</c>.
             <p>
             No checks are performed to ensure that the invoking
             <c>ILinearNumExpr</c> object does not contain terms with
             variables that also appear in the scalar product expression being added.
             This method can potentially create duplicate terms
             <c>... + a_i * x + ... + a_k * x + ...</c> that could be joined to
             a single term <c>... + (a_i + a_k) * x + ...</c>.</p>
             <p>
             Duplicates do not generate errors but require more memory and more
             running time when iterating through the terms of an
             <c>ILinearNumExpr</c>.
            </p>
             </remarks>
             <param name="sc">The scalar product expression, the terms of which are added
                       to the invoking object.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.Clear">
             <summary>
             Removes all terms from the invoking linear expression leaving a <c>0</c>
             expression behind.
             </summary>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.Remove(ILOG.Concert.INumVar)">
              <summary>
              Removes a variable from the invoking <c>ILinearNumExpr</c> expression.
              </summary>
             <remarks>  All terms in the invoking linear expression with the specified variable
              are removed from the invoking <c>ILinearNumExpr</c> object.  If
              variable <c>var</c> occurs more than once in the invoking
              <c>ILinearNumExpr</c>, all occurrences are removed.  The
              <c>ILinearNumExpr.Enumerator</c> can be used to remove individual
              terms regardless of duplicates.
            
              </remarks>
              <param name="var">The variable to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.Remove(ILOG.Concert.INumVar[],System.Int32,System.Int32)">
              <summary>
              Removes variables from the invoking <c>ILinearNumExpr</c>
              expression.
              </summary>
             <remarks>All terms in the invoking linear expression having any
              variable in <c>var[start], ..., var[start+num-1]</c> are removed
              from the invoking <c>ILinearNumExpr</c> object. If variable
              <c>var</c> occurs more than once in the invoking
              <c>ILinearNumExpr</c>, all occurrences are removed. The
              <c>ILinearNumExpr.Enumerator</c> can be used to remove individual
              terms regardless of duplicates.
            
              
            
             </remarks>
             <param name="var">The array containing the variables to be removed.
              </param>
              <param name="start">The index of the first variable in <c>var</c> to be removed.
              </param>
              <param name="num">The number of variables in <c>var</c> to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.Remove(ILOG.Concert.INumVar[])">
              <summary>
              Removes variables from the invoking <c>ILinearNumExpr</c>
              expression.
              </summary>
             <remarks>All terms in the invoking linear expression having any
              variable in <c>var[0], ..., var[num-1]</c> are removed from the
              invoking <c>ILinearNumExpr</c> object, where <c>num</c> is
              the length of array <c>var</c>.  If variable <c>var</c> occurs
              more than once in the invoking <c>ILinearNumExpr</c>, all
              occurrences are removed.  The <c>ILinearNumExpr.Enumerator</c>
              can be used to remove individual terms regardless of duplicates.
            
              </remarks>
              <param name="var">The array of variables to be removed.</param>
        </member>
        <member name="M:ILOG.Concert.ILinearNumExpr.GetLinearEnumerator">
             <summary>
             Returns an enumerator for the variables in the invoking <c>ILinearNumExpr</c>
             expression.
             </summary>
        </member>
        <member name="P:ILOG.Concert.ILinearNumExpr.Constant">
               <summary>
               Queries the constant term from the invoking <c>ILinearIntExpr</c>.
               </summary>
        </member>
        <member name="T:ILOG.Concert.ILinearNumExprEnumerator">
             <summary>
             This is the enumerator for the linear terms of an <c>ILinearNumExpr</c>
             expression object.
             </summary>
            <remarks>The enumerator allows the caller to enumerate
             all the terms of an <c>ILinearNumExpr</c> and perform simple
             operations, such as querying or modifying a term. During the iteration,
             the caller can remove elements from the underlying
             <c>ILinearNumExpr</c> using well-defined semantics.
             </remarks>
        </member>
        <member name="P:ILOG.Concert.ILinearNumExprEnumerator.NumVar">
               <summary>
               Gets/sets the <c>INumVar</c> accessed by the last call to the method <c>MoveNext()</c>.
               </summary>
        </member>
        <member name="P:ILOG.Concert.ILinearNumExprEnumerator.Value">
               <summary>
               Gets/sets the coefficient related to the <c>INumVar</c> accessed by the last
               call to the method <c>MoveNext()</c>.
               </summary>
        </member>
        <member name="T:ILOG.Concert.IModel">
             <summary>
             This interface defines the API for classes that represent optimization models.
             </summary>
            <remarks>  An <c>IModel</c> extractable is a multiple set of modeling objects,
             such as constraints or objectives. Objects of type <c>IAddable</c>
             can be added to and removed from an <c>IModel</c>. The modeling
             objects in a model can be queried using the enumerator returned by method
             <c>GetEnumerator()</c>.
             <p>
             An important point is that optimizers such as <c>CP</c> or
             <c>Cplex</c> implement the <c>IModel</c> interface
             through its extension <c>IModeler</c>. The model associated with
             an optimizer is the model the optimizer will solve upon invocation of its
             method <c>solve()</c>.</p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModel.Add(ILOG.Concert.IAddable)">
             <summary>
             This method adds the extractable object to the invoking
             model.
             </summary>
            <param name="obj">The modeling object to be added to the invoking <c>IModel</c>.
             </param>
             <returns>The modeling object that has been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IModel.Add(ILOG.Concert.IAddable[])">
             <summary>
             This method adds the array of extractable objects to the invoking
             model.
             </summary>
            
            <param name="objects">The array of modeling objects to be added to the
                            invoking <c>IModel</c>.
             </param>
             <returns>The array of modeling objects that have been added.
             </returns>
        </member>
        <member name="M:ILOG.Concert.IModel.Add(ILOG.Concert.IAddable[],System.Int32,System.Int32)">
             <summary>
             This method adds modeling objects to the invoking <c>IModel</c>.
             </summary>
            <remarks>  All objects implementing the <c>IAddable</c> interface
             <c>objects[start]...objects[start+num-1]</c> are added to
             the invoking <c>IModel</c> object.
            </remarks>
            <param name="objects">The array of modeling objects to be added
                            to the invoking <c>IModel</c>.
             </param>
             <param name="start">The first modeling object to be added to the
                          invoking <c>IModel</c>.
             </param>
             <param name="num">The number of modeling objects to be added to
                        the invoking <c>IModel</c>.
             </param>
             <returns>The array of modeling objects that have been added.
             </returns>
        </member>
        <member name="M:ILOG.Concert.IModel.Remove(ILOG.Concert.IAddable)">
              <summary>
              This method removes the extractable object from the invoking
              model.
              </summary>
             <remarks>If the modeling object has been added
              multiple times, only one instance is removed from the model.
            
              </remarks>
              <param name="object">The modeling object to be removed from the invoking
                                <c>IModel</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IModel.Remove(ILOG.Concert.IAddable[])">
             <summary>
             This method removes the array of extractable objects
             from the invoking model.
             </summary>
            <remarks>
             
            </remarks>
            <param name="objects">The array of modeling objects to be removed from the
                           invoking <c>IModel</c>.
             </param>
        </member>
        <member name="M:ILOG.Concert.IModel.Remove(ILOG.Concert.IAddable[],System.Int32,System.Int32)">
             <summary>
             This method removes modeling objects from the invoking <c>IModel</c>.
             </summary>
             <remarks>  The modeling objects or, more precisely, the objects implementing
              the IAddable interface
              <c>objects[start]...objects[start+num-1]</c> are removed
              from the invoking <c>IModel</c> object. If a modeling object
              has been added multiple times, only one instance is removed
              from the model.
            </remarks>
             <param name="objects">The array of modeling objects to be removed
                             from the invoking <c>IModel</c>.
              </param>
              <param name="start">The first modeling object to be removed from the
                           invoking <c>IModel</c>.
              </param>
              <param name="num">The number of modeling objects to be removed from
                         the invoking <c>IModel</c>.
              </param>
        </member>
        <member name="M:ILOG.Concert.IModel.GetEnumerator">
             <summary>
             This method returns an enumerator that traverses the objects in
             the model.
             </summary>
            <remarks>Any manipulation of the model will render an
             enumerator accessed with this method invalid. An enumerator
             can only be used until the method <c>add, remove</c> or
             the method <c>delete</c> is called on the invoking
             <c>IModel</c>.</remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.ScalProd(ILOG.Concert.INumVar[],ILOG.Concert.INumVar[])">
            <summary>
            Creates and returns a linear expression representing the scalar product
            of the variables provided as arguments.
            </summary>
            <param name="vars1">The first array of variables involved in the new 
                              scalar product expression.
            </param>
            <param name="vars2">The second array of variables involved in the new 
                              scalar product expression.
            </param>
            <returns>The new linear expression.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.ScalProd(ILOG.Concert.INumVar[],ILOG.Concert.INumVar[],System.Int32,System.Int32)">
             <summary>
             Creates and returns a linear expression representing the scalar product
             of the variables provided as arguments.
             </summary>
             <remarks> <p>This signature of the method allows you to indicate a starting 
             point and a number of consecutive terms for the scalar multiplication.
             In other words, the entire array <c>vars1</c> will not be
             involved in the scalar multiplication. The method will take into 
             account only the term at the starting point and <c>num</c>
             consecutive terms in total. </p>
             
            
            
            
             </remarks>
             <param name="vars1">The first array of variables involved in the new scalar
                               product expression.
             </param>
             <param name="vars2">The second array of variables involved in the 
                               new scalar product expression.
             </param>
             <param name="start">The index of the starting term for the multiplication.
             </param>
             <param name="num">The total number of terms in the multiplication.
             </param>
             <returns>The new linear expression.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Negative(ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns the new expression <c>-e</c>,
             the negation of the expression <c>e</c>.
             </summary>
            <param name="e">An expression for which the negative value is given.
             </param>
             <returns>An expression representing the 
                       negation of <c>e</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,System.Double)">
            <summary>
            Creates and returns an expression representing the
             sum of a numeric expression and a value.
             </summary>
            <param name="e">The numeric expression.
             </param>
             <param name="v">The value.
             </param>
             <returns>An expression representing the sum of <c>e + v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(System.Double,ILOG.Concert.INumExpr)">
            <summary>
            Creates and returns an expression representing the
             sum of a value and a numeric expression.
             </summary>
            <param name="v">The value.
             </param>
             <param name="e">The numeric expression.
             </param>
             <returns>An expression representing the sum of <c>v + e</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds two numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds three numeric expressions and returns their sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds four numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <param name="e4">The fourth numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3 + e4</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds five numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions. </p>
             
            
            
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <param name="e4">The fourth numeric expression.
             </param>
             <param name="e5">The fifth numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3 + e4 + e5</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds six numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <param name="e4">The fourth numeric expression.
             </param>
             <param name="e5">The fifth numeric expression.
             </param>
             <param name="e6">The sixth numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3 + e4 + e5 + e6</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds seven numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <param name="e4">The fourth numeric expression.
             </param>
             <param name="e5">The fifth numeric expression.
             </param>
             <param name="e6">The sixth numeric expression.
             </param>
             <param name="e7">The seventh numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3 + e4 + e5 + e6 + e7</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Adds eight numeric expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
            
            
            
             </remarks>
             <param name="e1">The first numeric expression.
             </param>
             <param name="e2">The second numeric expression.
             </param>
             <param name="e3">The third numeric expression.
             </param>
             <param name="e4">The fourth numeric expression.
             </param>
             <param name="e5">The fifth numeric expression.
             </param>
             <param name="e6">The sixth numeric expression.
             </param>
             <param name="e7">The seventh numeric expression.
             </param>
             <param name="e8">The eighth numeric expression.
             </param>
             <returns>A numeric expression representing the
                     sum of <c>e1 + e2 + e3 + e4 + e5 + e6 + e7 + e8</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr[],System.Int32,System.Int32)">
            <summary>
            Creates and returns an expression representing the sum of
            the <c>num</c> expressions provided as terms 
            in the array <c>expr</c>
            starting with element <c>start</c>.
            </summary>
            <param name="expr">An array containing the expressions to be summed.
            </param>
            <param name="start">The first term in <c>expr</c> to be used.
            </param>
            <param name="num">The number of terms in <c>expr</c> to be used.
            </param>
            <returns>An expression representing the sum of the specified terms.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.INumExpr[])">
            <summary>
            Creates and returns an expression representing the sum of
            the expressions provided as terms in the array <c>expr</c>.
            </summary>
            <param name="expr">An array containing the terms to be summed.
            </param>
            <returns>An expression representing the sum of the specified terms.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns an expression representing the 
             difference between expression
             <c>e</c> and value <c>v</c>.
             </summary>
            <param name="e">An expression to use in the difference.
             </param>
             <param name="v">A value to subtract.
             </param>
             <returns>An expression representing the difference <c>e - v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an expression representing the difference 
             between the expressions
             <c>e1</c> and <c>e2</c>.
             </summary>
            <param name="e1">An expression to use in the difference.
             </param>
             <param name="e2">An expression to subtract.
             </param>
             <returns>An expression representing the difference <c>e1 - e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an expression representing the difference 
             between the value
             <c>v</c> and the expression <c>e1</c>.
             </summary>
            <param name="v">A value to use in the difference.
             </param>
             <param name="e1">An expression to subtract.
             </param>
             <returns>An expression representing the difference <c>v - e1</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns an expression representing the product of 
             the expression
             <c>e</c> and the value <c>v</c>.
             </summary>
            <param name="e">An expression to use in the product.
             </param>
             <param name="v">A value to add.
             </param>
             <returns>An expression representing the product <c>e * v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an expression representing the product of 
             the expressions
             <c>expr1</c> and <c>expr2</c>.
             </summary>
            <param name="expr1">An expression to use in the product.
             </param>
             <param name="expr2">An expression to use in the product.
             </param>
             <returns>An expression representing the product <c>expr1 * expr2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an expression representing the product of 
             the expression
             <c>e1</c> and the value <c>v</c>.
             </summary>
            <param name="e1">An expression to use in the product.
             </param>
             <param name="v">A value to use in the product.
             </param>
             <returns>An expression representing the product <c>e1 * v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(System.Double,ILOG.Concert.INumVar,ILOG.Concert.INumVar)">
             <summary>
             Creates and returns an expression representing the product
             of the value <c>val</c>, the variable<c>var1</c>, 
             and the variable <c>var2</c>.
             </summary>
            <param name="val">The value to be used in the product.
             </param>
             <param name="var1">The first variable to be used in the product.
             </param>
             <param name="var2">The second variable to be used in the product.
             </param>
             <returns>An expression representing the product
                          <c>val * var1 * var2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.INumVar,System.Double,ILOG.Concert.INumVar)">
             <summary>
             Creates and returns an expression representing the product of 
             the variable<c>var1</c>,
             the value <c>val</c>, 
             and the variable <c>var2</c>.
             </summary>
            <param name="var1">The first variable to be used in the product.
             </param>
             <param name="val">The value to be used in the product.
             </param>
             <param name="var2">The second variable to be used in the product.
             </param>
             <returns>An expression representing the product
                          <c>val * var1 * var2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.INumVar,ILOG.Concert.INumVar,System.Double)">
             <summary>
             Creates and returns an expression representing the product of 
             the variable<c>var1</c>, 
             the variable <c>var2</c>, and 
             the value <c>val</c>,
             </summary>
            <param name="var1">The first variable to be used in the product.
             </param>
             <param name="var2">The second variable to be used in the product.
             </param>
             <param name="val">The value to be used in the product.
             </param>
             <returns>An expression representing the product
                          <c>var1 * var2 * val</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Square(ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an expression representing the 
             square of the expression
             <c>e</c> (that is, <c>e * e</c>).
             </summary>
            <param name="e">An expression to use in the square.
             </param>
             <returns>An expression representing the product <c>e * e</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Constant(System.Double)">
             <summary>
             Creates and returns an expression representing the 
            constant term <c>x</c>.
            </summary>
            <remarks> <p>
            This method does not need to be called by the user, 
            as overloaded versions of all methods involving expressions 
            are available to deal directly with constants.</p>
             
            </remarks>
            <param name="x">A value for which to construct a constant expression term.
             </param>
             <returns>An expression representing the constant <c>x</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.NumExpr">
              <summary>
              Creates and returns an empty expression.
              </summary>
            <returns>An expression.</returns> 
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns the new expression <c>max(e1, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns the new expression <c>max(val, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns the new expression <c>max(e1, val)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.INumExpr[])">
             <summary>
             Creates and returns the new expression <c>max(e)</c>.
             </summary>
            <param name="e">The array of expressions.</param>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns the new expression <c>min(e1, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns the new expression <c>min(val, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns the new expression <c>min(e1, val)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.INumExpr[])">
             <summary>
             Creates and returns the new expression <c>min(e)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.ScalProd(ILOG.Concert.IIntVar[],ILOG.Concert.IIntVar[])">
            <summary>
            Creates and returns a linear expression representing the scalar product
            of the provided variables.
            </summary>
            <param name="vars1">The first array of variables involved in the new scalar
                          product expression.
            </param>
            <param name="vars2">The second array of variables involved in the new 
                          scalar product expression.
            </param>
            <returns>The new linear expression.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.ScalProd(ILOG.Concert.IIntVar[],ILOG.Concert.IIntVar[],System.Int32,System.Int32)">
            <summary>
            Creates and returns a linear expression representing the scalar product
            of the variables provided as arguments.
            </summary>
            <param name="vars1">The first array of variables involved in the new scalar
                              product expression.
            </param>
            <param name="vars2">The second array of variables involved in the new 
                              scalar product expression.
            </param>
            <param name="start">First element in <c>vars1</c> and 
                               <c>vars2</c> to be used for the scalar product.
            </param>
            <param name="num">Number of elements in <c>vars1</c> and
                               <c>vars2</c> to be used for the scalar product.
            </param>
            <returns>The new linear expression.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,System.Int32)">
             <summary>
             Creates and returns an integer expression representing the sum of
             an integer expression and a value.
             </summary>
            <param name="e">The integer expression.
             </param>
             <param name="v">The value.
             </param>
             <returns>An integer expression representing the sum <c>e + v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(System.Int32,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns an integer expression representing the sum of
             a value and an integer expression.
             </summary>
            <param name="v">The value.
             </param>
             <param name="e">The integer expression.
             </param>
             <returns>An integer expression representing the sum <c>e + v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds two integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <returns>An integer expression representing the
                     sum <c>e1 + e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds three integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 +e2 +e3</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds four integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <param name="e4">The fourth integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 + e2 + e3 +e 4</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds five integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <param name="e4">The fourth integer expression.
             </param>
             <param name="e5">The fifth integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 + e2 + e3 + e4 + e5</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds six integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions. </p>
             
            
            
            
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <param name="e4">The fourth integer expression.
             </param>
             <param name="e5">The fifth integer expression.
             </param>
             <param name="e6">The sixth integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 + e2 + e3 + e4 + e5 + e6</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds seven integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <param name="e4">The fourth integer expression.
             </param>
             <param name="e5">The fifth integer expression.
             </param>
             <param name="e6">The sixth integer expression.
             </param>
             <param name="e7">The seventh integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 + e2 + e3 + e4 + e5 + e6 + e7</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Adds eight integer expressions and returns the sum.
             </summary>
             <remarks> <p>The domain of the resulting expression is computed from
             the domains of the combined expressions.</p>
             
            
            
            
            
            
            
            
             </remarks>
             <param name="e1">The first integer expression.
             </param>
             <param name="e2">The second integer expression.
             </param>
             <param name="e3">The third integer expression.
             </param>
             <param name="e4">The fourth integer expression.
             </param>
             <param name="e5">The fifth integer expression.
             </param>
             <param name="e6">The sixth integer expression.
             </param>
             <param name="e7">The seventh integer expression.
             </param>
             <param name="e8">The eighth integer expression.
             </param>
             <returns>The expression <c>exp</c>, representing the
                     sum <c>e1 + e2 + e3 + e4 + e5 + e6 + e7 + e8</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr[],System.Int32,System.Int32)">
            <summary>
            Creates and returns an integer expression representing the sum of
            the <c>num</c> expressions provided in the array <c>expr</c>
            starting with element <c>start</c>.
            </summary>
            <param name="expr">An array containing the expressions to be summed.
            </param>
            <param name="start">The first expression in <c>expr</c> to be used.
            </param>
            <param name="num">The number of expressions in <c>expr</c> to be used.
            </param>
            <returns>An integer expression representing the sum of the specified expressions.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Sum(ILOG.Concert.IIntExpr[])">
            <summary>
            Creates and returns an integer expression representing the sum of
            the expressions provided in the array <c>expr</c>.
            </summary>
            <param name="expr">An array containing the expressions to be summed.
            </param>
            <returns>An integer expression representing the sum of the specified expressions.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(ILOG.Concert.IIntExpr,System.Int32)">
             <summary>
             Creates and returns an integer expression representing the difference
             between integer expression <c>e</c> and value <c>v</c>.
             </summary>
            <param name="e">An integer expression to use in the difference.
             </param>
             <param name="v">A value to subtract
             </param>
             <returns>An integer expression representing the difference <c>e - v</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns an integer expression representing the difference
             between the integer expressions <c>expr1</c> 
             and <c>expr2</c>.
             </summary>
            <param name="expr1">An integer expression to use in the difference.
             </param>
             <param name="expr2">An integer expression to subtract.
             </param>
             <returns>An integer expression representing the difference
                               <c>expr1 - expr2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Diff(System.Int32,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns an integer expression representing the difference
             between the value <c>v</c> and the integer expression <c>e1</c>.
             </summary>
            <param name="v">A value to use in the difference.
             </param>
             <param name="e1">An integer expression to subtract.
             </param>
             <returns>An integer expression representing 
                        the difference <c>v - e1</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.IIntExpr,System.Int32)">
             <summary>
             Creates and returns the new expression <c>e * v</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>e1 * e2</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Prod(System.Int32,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>v * e</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Square(ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>e^2</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Constant(System.Int32)">
             <summary>
             Creates and returns a new constant expression equal to
             <c>x</c>.
             </summary>
            <param name="x">The value of the constant expression.
             </param>
             <returns>The constant expression.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.IntExpr">
             <summary>
             Creates and returns an empty expression as an object.
             </summary>
            <returns>An empty expression as an object.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>max(e1, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(System.Int32,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>max(val, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.IIntExpr,System.Int32)">
             <summary>
             Creates and returns the new expression <c>max(e1, val)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Max(ILOG.Concert.IIntExpr[])">
             <summary>
             Creates and returns the new expression <c>max(e)</c>.
             </summary>
            <param name="e">the array of expressions</param>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.IIntExpr,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>min(e1, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(System.Int32,ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>min(val, e2)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.IIntExpr,System.Int32)">
             <summary>
             Creates and returns the new expression <c>min(e1, val)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Min(ILOG.Concert.IIntExpr[])">
             <summary>
             Creates and returns the new expression <c>min(e)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Abs(ILOG.Concert.IIntExpr)">
             <summary>
             Creates and returns the new expression <c>abs(e)</c>.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Eq(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IConstraint</c>  
             initialized to represent the constraint <c>e1 == e2</c>.
             </summary>
            <param name="e1">Lefthand side expression of the new equality constraint.
             </param>
             <param name="e2">Righthand side expression of the new equality constraint.
             </param>
             <returns>A new instance of <c>IConstraint</c> 
                       initialized to represent the constraint <c>e1 == e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Eq(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>expr == rhs</c>.
             </summary>
            <param name="expr">Expression of the new equality constraint.
             </param>
             <param name="rhs">Upper bound of the new equality constraint.
             </param>
             <returns>A new <c>IRange</c> object initialized to 
                          represent the constraint <c>expr == rhs</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Eq(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>val == expr</c>.
             </summary>
            <param name="val">Value of the new equality constraint.
             </param>
             <param name="expr">Expression of the new equality constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                         initialized to represent the
                         constraint <c>val == expr</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Le(ILOG.Concert.INumExpr,System.Double)">
            <summary>
            Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>expr &lt;= rhs</c>.
             </summary>
            <param name="expr">Expression of the new less-than-or-equal-to constraint.
             </param>
             <param name="rhs">Upper bound of the new less-equal-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                         initialized to represent the
                         constraint <c>expr &lt;= rhs</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Le(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IConstraint</c> 
             initialized to represent the constraint <c>e1 &lt;= e2</c>.
             </summary>
            <param name="e1">Lefthand side expression of the new 
                       less-equal-than-or-equal-to constraint.
             </param>
             <param name="e2">Righthand side expression of the new 
                       less-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IConstraint</c> object 
                       initialized to represent the
                       constraint <c>e1 &lt;= e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Le(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>val &lt;= expr</c>.
             </summary>
            <param name="val">Value of the new less-than-or-equal-to constraint.
             </param>
             <param name="expr">Expression of the new less-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                         initialized to represent the
                         constraint <c>val &lt;= expr</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Ge(ILOG.Concert.INumExpr,System.Double)">
             <summary>
             Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>expr &gt;= rhs</c>.
             </summary>
            <param name="expr">Expression of the new greater-than-or-equal-to constraint.
             </param>
             <param name="rhs">Upper bound of the new greater-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                         initialized to represent the
                         constraint <c>expr &gt;= rhs</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Ge(ILOG.Concert.INumExpr,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an <c>IRange</c> 
             initialized to represent the constraint <c>e1 &gt;= e2</c>.
             </summary>
            <param name="e1">Lefthand side expression of the new 
                           greater-than-or-equal-to constraint.
             </param>
             <param name="e2">Righthand side expression of the new 
                           greater-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                           initialized to represent the
                           constraint <c>e1 &gt;= e2</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Ge(System.Double,ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IRange</c> 
             initialized to represent the constraint <c>val &gt;= expr</c>.
             </summary>
            <param name="val">Value of the new greater-than-or-equal-to constraint.
             </param>
             <param name="expr">Expression of the new greater-than-or-equal-to constraint.
             </param>
             <returns>A new <c>IRange</c> object 
                           initialized to represent the
                           constraint <c>val &gt;= expr</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Maximize(ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IObjective</c> 
             representing an objective to maximize the expression <c>expr</c>.
             </summary>
            <param name="expr">Expression to maximize.
             </param>
             <returns>An <c>IObjective</c> object representing the 
                         objective to maximize <c>expr</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.Minimize(ILOG.Concert.INumExpr)">
             <summary>
             Creates and returns an instance of <c>IObjective</c> 
             representing an objective to minimize the expression <c>expr</c>.
             </summary>
            <param name="expr">Expression to minimize.
             </param>
             <returns>An <c>IObjective</c> object representing the objective
                       to minimize <c>expr</c>.</returns>
        </member>
        <member name="M:ILOG.Concert.IModeler.And">
            
             <remarks>
             Creates an <c>IAnd</c> constraint suitable for grouping
             other constraints or building logical constraints.  Constraints can be
             added and removed to the <c>IAnd</c> constraint by using its
             methods <c>Add</c> and <c>Remove</c>.
             
             </remarks>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint[])">
             <summary>
             Groups several constraints together.
             </summary>
             <param name="cons">The array of constraints to group.
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint[],System.String)">
             <summary>
             Groups several constraints together.
             </summary>
             <param name="cons">The array of constraints to group.
             </param>
             <param name="name">The name of the resulting and-constraint.
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
             <summary>
             Groups several constraints together.
             </summary>
             <param name="cons">The array of constraints to group.
             </param>
             <param name="start">Index of the first constraint in the resulting and-constraint.
             </param>
             <param name="num">Number of constraints in the resulting and-constraint.
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint[],System.Int32,System.Int32,System.String)">
             <summary>
             Groups several constraints together.
             </summary>
             <param name="cons">The array of constraints to group.
             </param>
             <param name="start">Index of the first constraint in the resulting and-constraint.
             </param>
             <param name="num">Number of constraints in the resulting and-constraint.
             </param>
             <param name="name">The name of the and-constraint.
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint)">
             <summary>
             Group several constraints together.
             </summary>
             <param name="con1">The first constraint to group.
             </param>
             <param name="con2">The second constraint to group. 
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.And(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint,System.String)">
             <summary>
             Group several constraints together.
             </summary>
             <param name="con1">The first constraint to group.
             </param>
             <param name="con2">The second constraint to group. 
             </param>
             <param name="name">The name of the resulting and-constraint.
            
             </param>
             <see cref="T:ILOG.Concert.IAnd"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or">
            
             <remarks>
             Creates an <c>IOr</c> constraint for expressing disjunctions.
             Constraints can be
             added and removed to the <c>IOr</c> constraint by using its
             methods <c>Add</c> and <c>Remove</c>.
             
             </remarks>
             <see cref="T:ILOG.Concert.IOr"/>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint[])">
            
             <remarks>
              Returns an <c>IOr</c> constraint indicating that at least one and possibly more than one
              of the elements is true in its argument <c>cons</c>, an array
              of constraints.
              <p>In other words, it returns the logical-or of
              two or more constraints. </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint[],System.String)">
             <summary>
             Returns an <c>IOr</c> constraint indicating that at least one and 
             possibly more than one
             of the elements is true in its argument <c>cons</c>, an array
             of constraints.
             </summary>
            <remarks>
             <p>In other words, it returns the logical-or of
             two or more constraints. </p>
             <p>It also assigns the string <c>name</c> as the
             name of that returned constraint. </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
             <summary>
             Returns an or-constraint indicating that at least one and 
             possibly more than one
             of the elements is true in the range of indices starting at the index
             indicated by <c>start</c> and continuing through the number
             of elements indicated by the number <c>num</c> among the elements
             of its argument <c>cons</c>, an array of constraints.
             </summary>
            <remarks>  <p>In other words, it returns the logical-or of
             two or more constraints. </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint[],System.Int32,System.Int32,System.String)">
             <summary>
             Returns an or-constraint indicating that at least one and 
             possibly more than one
             of the elements is true in the range of indices starting at the index
             indicated by <c>start</c> and continuing through the number
             of elements indicated by the number <c>num</c> among the elements
             of its argument <c>cons</c>, an array of constraints.
             </summary>
            <remarks>  <p>In other words, it returns the logical-or of
             two or more constraints. </p>
            <p>
             This method also assigns the string <c>name</c> as the name of
             the returned constraint.
            </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint)">
             <summary>
             Returns an or-constraint indicating that at least one and possibly more
             than one argument is true.
             </summary>
            <remarks>
             <p>In other words, it returns the logical-or of
             two constraints. </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Or(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint,System.String)">
             <summary>
             Returns an or-constraint indicating that at least one and possibly both of
             its  arguments are true.
             </summary>
            <remarks>
             <p>In other words, it returns the logical-or of
             two constraints. It also assigns the string <c>name</c> as
             the name of that returned constraint.</p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.IfThen(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint)">
             <summary>
             Returns a constraint that if <c>con1</c> is true, then 
             <c>con2</c> must also be true.
             </summary>
            <remarks>
             <p>In other words, it returns
             a conditional constraint based on its arguments.</p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.IfThen(ILOG.Concert.IConstraint,ILOG.Concert.IConstraint,System.String)">
             <summary>
             Returns a constraint that if <c>con1</c> is true, then 
             <c>con2</c> must also be true.
             </summary>
            <remarks>
             <p>In other words, it returns
             a conditional constraint based on its arguments. It also assigns
             the string <c>name</c> as the name of the returned constraint.
             </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IModeler.Not(ILOG.Concert.IConstraint)">
             <summary>
             Returns a constraint that is the logical negation of its argument.
             </summary>
        </member>
        <member name="M:ILOG.Concert.IModeler.Not(ILOG.Concert.IConstraint,System.String)">
             <summary>
             Returns a constraint that is the logical negation of its argument 
             and assigns the string <c>name</c> as the name of the
             returned constraint.
             </summary>
        </member>
        <member name="T:ILOG.Concert.IObjective">
              <summary>
              This interface defines the API for objectives.
              </summary>
             <remarks>  An objective function is defined by an objective expression and an
              optimization sense. The objective sense is represented by
              <c>ObjectiveSense</c> objects and can be
              <c>ObjectiveSense.Minimize</c> or
              <c>ObjectiveSense.Maximize</c>.
              <p>
              Both the objective sense and expression can be queried and reset.
              In addition to this, the CPLEX class <c>IloMPModeler</c> provides methods
              for manipulating linear objective expressions through its methods
              <c>setLinearCoef()</c> and <c>setLinearCoefs()</c>.
              <c>IloMPModeler</c> is available to users of ILOG CPLEX.</p>
            
              
              
              
              
              
              
              </remarks>
              <see cref="T:ILOG.Concert.ObjectiveSense"/><see cref="!:IModeler.addObjective(ObjectiveSense, INumExpr)"/><see cref="!:IModeler.addMaximize(INumExpr)"/><see cref="!:IModeler.addMinimize(INumExpr)"/><see cref="!:IModeler.objective(ObjectiveSense, INumExpr)"/><see cref="!:IModeler.maximize(INumExpr)"/><see cref="!:IModeler.minimize(INumExpr)"/>
        </member>
        <member name="P:ILOG.Concert.IObjective.Sense">
               <summary>
               Queries/sets the optimization sense of the invoking <c>IObjective</c> object.
               </summary>
        </member>
        <member name="P:ILOG.Concert.IObjective.Expr">
               <summary>
               Queries/sets the expression of the invoking <c>IObjective</c> object.
               </summary>
        </member>
        <member name="T:ILOG.Concert.IOr">
             <summary>
             This interface defines the API for classes that represent or-constraints.
             </summary>
            <remarks>  <p>
             An instance of <c>IOr</c> (that is, an or-constraint) 
             indicates that at least one of a set of
             constraints must be satisfied.
             Objects of type <c>IConstraint</c> can be added to and removed from 
             an instance of <c>IOr</c>. 
             The constraints in an or-constraint can be queried by the 
             enumerator returned by method <c>GetEnumerator()</c>.
             </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IOr.Add(ILOG.Concert.IConstraint)">
             <summary>
             This method adds the constraint to the invoking or-constraint.
             </summary>
            <param name="ct">The constraint to be added to the invoking 
                           instance of <c>IOr</c>.
             </param>
             <returns>The constraint that has been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IOr.Add(ILOG.Concert.IConstraint[])">
             <summary>
             This method adds the array of constraints to the invoking
             or-constraint.
             </summary>
            <param name="objects">The array of constraints to be added to the
                            invoking instance of <c>IOr</c>.
             </param>
             <returns>The array of constraints that have been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IOr.Add(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
              <summary>
              This method adds constraints to the invoking 
              instance of <c>IOr</c>.
              </summary>
             <remarks>  <p>
              All objects implementing the <c>IConstraint</c> interface
              <c>objects[start]...objects[start+num-1]</c> are added to
              the invoking <c>IOr</c> object.
              </p>
              
            
            
             </remarks>
             <param name="objects">The array of constraints to be added
                             to the invoking instance of <c>IOr</c>.
              </param>
              <param name="start">The first constraint to be added to the
                           invoking instance of <c>IOr</c>.
              </param>
              <param name="num">The number of constraints to be added to
                         the invoking instance of <c>IOr</c>.
              </param>
              <returns>The array of constraints that have been added.</returns>
        </member>
        <member name="M:ILOG.Concert.IOr.Remove(ILOG.Concert.IConstraint)">
              <summary>
              This method removes a constraint from the invoking
              or-constraint.
              </summary>
             <remarks>
              <p>If the constraint has been added multiple times, only one 
             	instance is removed from the or-constraint.
              </p>
            
              </remarks>
              <param name="ct">The constraint to be removed from the invoking
                                instance of <c>IOr</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IOr.Remove(ILOG.Concert.IConstraint[])">
             <summary>
             This method removes an array of constraints
             from the invoking or-constraint.
             </summary>
            <param name="objects">The array of constraints to be removed from the
                           invoking <c>IOr</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IOr.Remove(ILOG.Concert.IConstraint[],System.Int32,System.Int32)">
              <summary>
              This method removes constraints from the invoking instance of 
              <c>IOr</c>.
              </summary>
             <remarks>  <p>
              The constraints or, more precisely, the objects implementing
              the <c>IConstraint</c> interface
              <c>objects[start]...objects[start+num-1]</c> are removed
              from the invoking instance of <c>IOr</c>. If a constraint
              has been added multiple times, only one instance is removed
              from the or-constraint.
              </p>
              
            
             </remarks>
             <param name="objects">The array of constraints to be removed
                             from the invoking instance of <c>IOr</c>.
              </param>
              <param name="start">The first constraints to be removed from the
                           invoking instance of <c>IOr</c>.
              </param>
              <param name="num">The number of constraints to be removed from
                         the invoking instance of <c>IOr</c>.</param>
        </member>
        <member name="M:ILOG.Concert.IOr.GetEnumerator">
             <summary>
             This method returns an enumerator that traverses the constraints in
             the or-constraint.
             </summary>
            <remarks>
             <p>Any manipulation of the or-constraint will render an
             enumerator accessed with this method invalid. An enumerator
             can only be used until the method <c>add, remove</c>, or
             <c>delete</c> is called on the invoking instance of 
             <c>IOr</c>. </p></remarks>
        </member>
        <member name="M:ILOG.Concert.IRange.SetBounds(System.Double,System.Double)">
             <summary>
             Sets the lower and upper bound of the ranged constraints.
             </summary>
            <param name="lb">The new lower bound of the ranged constraints.
             </param>
             <param name="ub">The new upper bound of the ranged constraints.</param>
        </member>
        <member name="M:ILOG.Concert.IRange.ClearExpr">
            <summary>
            Sets the expression of the ranged constraint to <c>0</c>.
            </summary>
        </member>
        <member name="P:ILOG.Concert.IRange.LB">
               <summary>
               Queries/sets the lower bound of the ranged constraints.
               </summary>
        </member>
        <member name="P:ILOG.Concert.IRange.UB">
               <summary>
               Queries/sets the upper bound of the ranged constraints.
               </summary>
        </member>
        <member name="P:ILOG.Concert.IRange.Expr">
               <summary>
               Queries/sets the expression of the ranged constraint.
               </summary>
        </member>
        <member name="F:ILOG.Concert.NumVarType.Float">
            <summary>
            Floating point or, equivalently, continuous variable type.
            </summary>
        </member>
        <member name="F:ILOG.Concert.NumVarType.Int">
            <summary>
            Integer variable type.
            </summary>
        </member>
        <member name="F:ILOG.Concert.NumVarType.Bool">
            <summary>
            Boolean or, equivalently, binary variable type.
            </summary>
        </member>
        <member name="T:ILOG.Concert.ObjectiveSense">
             <summary>
             Objects of this class represent the sense of an <c>IObjective</c>
             object.
             </summary>
            <remarks>Two types are defined: <c>Minimize</c> and <c>Maximize</c>.</remarks>
        </member>
        <member name="F:ILOG.Concert.ObjectiveSense.Minimize">
            <summary>
            Indicates the objective sense for minimization.
            </summary>
        </member>
        <member name="F:ILOG.Concert.ObjectiveSense.Maximize">
            <summary>
            Indicates the objective sense for maximization.
            </summary>
        </member>
    </members>
</doc>
